#!/usr/bin/env python3
# ZK Studio — LEG-2025-101 (concise)
# MiMC (BN254), Merkle root from path, minimal Circom generator.

import argparse, json

# BN254 prime
P = 21888242871839275222246405745257275088548364400416034343698204186575808495617

# ----- MiMC (tiny) -----
def mimc(x: int, k: int = 0, rounds: int = 91) -> int:
    t = (x + k) % P
    for r in range(rounds):
        c = ((r + 1) ** 5 + 7) % P
        t = (t + c) % P
        t = pow(t, 3, P)
        t = (t + k) % P
    return t

def mimc_hash(vals):
    h = 0
    for v in vals:
        h = mimc((h + int(v)) % P)
    return h % P

# ----- Merkle (MiMC) -----
def merkle_parent(l: int, r: int) -> int:
    return mimc_hash([l % P, r % P])

def merkle_root(leaf: int, path):
    """
    path: JSON-serializable list of [neighbor, is_left], where is_left ∈ {0,1}.
    """
    a = leaf % P
    for n, is_left in path:
        a = merkle_parent(n, a) if int(is_left) else merkle_parent(a, n)
    return a % P

# ----- Circom generator (minimal) -----
CIRCOM_TMPL = """// Auto-generated by zk_studio.py (LEG-2025-101)
pragma circom 2.1.6;

// MiMC over BN254 (toy)
template MiMC(rounds){
    signal input in; signal input key; signal output out;
    var p = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    signal t; t <== (in + key) % p;
    var c;
    for (var r=0; r<rounds; r++){
        c = (((r+1) ** 5) + 7) % p;
        t <== (t + c) % p;
        t <== (t * t * t) % p;
        t <== (t + key) % p;
    }
    out <== t;
}

template MiMCHash2(rounds){
    signal input a; signal input b; signal output out;
    component f = MiMC(rounds);
    f.in <== (a + b); f.key <== 0; out <== f.out;
}

// Merkle membership using MiMC; dir[i]=1 means neighbor is left
template MerkleMembership(depth, rounds){
    signal input leaf; signal input root; signal input path[depth]; signal input dir[depth];
    signal output ok; signal cur; cur <== leaf;
    for (var i=0; i<depth; i++){
        component h = MiMCHash2(rounds);
        signal L; signal R;
        L <== dir[i]*path[i] + (1 - dir[i]) * cur;
        R <== dir[i]*cur     + (1 - dir[i]) * path[i];
        h.a <== L; h.b <== R; cur <== h.out;
    }
    ok <== cur === root;
}

component main = MerkleMembership({depth}, {rounds});
"""

def emit_circom(depth: int, rounds: int) -> str:
    return CIRCOM_TMPL.format(depth=depth, rounds=rounds)

# ----- CLI -----
def main():
    p = argparse.ArgumentParser(prog="zk_studio", description="ZK Studio — MiMC/Merkle helpers (LEG-2025-101)")
    sub = p.add_subparsers(dest="cmd", required=True)

    s1 = sub.add_parser("mimc-hash", help="Hash integers with MiMC (BN254).")
    s1.add_argument("values", nargs="+", help="e.g. 1 2 3 or hex 0x..")

    s2 = sub.add_parser("merkle-root", help="Compute Merkle root from leaf & path JSON.")
    s2.add_argument("--leaf", required=True, type=int)
    s2.add_argument("--path-json", required=True, help='JSON like [[neighbor,is_left], ...]')

    s3 = sub.add_parser("gen-circom", help="Emit minimal Circom circuit.")
    s3.add_argument("--depth", required=True, type=int)
    s3.add_argument("--rounds", default=91, type=int)
    s3.add_argument("--out", help="File to write")

    args = p.parse_args()

    if args.cmd == "mimc-hash":
        print(json.dumps({"prime": P, "hash": mimc_hash([int(x, 0) if isinstance(x, str) else int(x) for x in args.values])}, indent=2))
    elif args.cmd == "merkle-root":
        path = json.loads(args.path_json)
        print(json.dumps({"root": merkle_root(int(args.leaf), path), "depth": len(path)}, indent=2))
    elif args.cmd == "gen-circom":
        code = emit_circom(args.depth, args.rounds)
        if args.out:
            open(args.out, "w").write(code)
            print(f"Wrote {args.out}")
        else:
            print(code)

if __name__ == "__main__":
    main()
